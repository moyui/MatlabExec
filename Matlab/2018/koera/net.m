%以下参数记得调整！！！
cs=800;
xv=[128.37 126.14 126.76 126.07 126.51 125.82 126.20 127.5 128.96 129.59 129.35 128.37];%区域包围点经度值(注意首尾相连)
yv=[38.62 37.78 37.01 37.01 35.95 34.79 34.34 34.3 35 36.07 37.27 38.62];%区域包围点纬度值(同上)
cityshowX=[126.58 126.42 127.1 127.55 128.52 128.37 127.07 127.23 127.47 128.37 128.43 127.08 128.36 129.2 126.51 126.3 128.44 129.18 127.41 128.53 129.04];
cityshowY=[37.33 37.27 37.14 37.2 37.45 38.04 36.26 36.21 36.48 36.48 36.34 35.49 35.52 36.01 35.09 35.03 35.38 35.32 34.56 35.13 35.1];
%以下是各个城市，农村，中点坐标注意农村与中点要一一对应
middle={[126.76	37.52],[127.05 37.43],[127.09 37.29],[127.08 37.16],[127.13 37.03],[127.18 36.91],[127.17 36.78],[127.11 36.65],[127.11	36.5],[127.06 36.31],[127.04 36.19],[127.1 36.04],[127.05 35.88],[126.97 35.71],[126.79	35.54],[126.8 35.34],[126.95 35.23],[126.76	37.36],[126.76 37.2],[126.88 37.06],[126.77 36.98],[126.56 36.79],[126.58 36.56],[126.57 36.33],[126.62 36.14],[126.83 35.94],[126.76 35.72],[126.69 35.56],[126.64 35.4],[126.5 35.23],[126.48 35.03],[127.01 37.72],[127.17 37.55],[127.3 37.4],[127.42 37.25],[127.45 37.1],[127.46 36.95],[127.48 36.75],[127.43 36.57],[127.34 36.39],[127.24 36.19],[127.45 36.28],[127.5 36.12],[127.66 35.95],[127.57 35.74],[127.32 35.79],[127.27 35.72],[127.31 35.56],[127.39 35.3],[127.52 35],[127.76 35.54],[127.93 35.31],[128.09 35.14],[127.57 37.23],[127.75 37.04],[127.91 36.87],[128.13 36.67],[128.22 36.37],[128.27 36.16],[128.23 35.94],[128.38 35.75],[128.47 35.55],[128.49 35.29],[127.93 37.64],[127.91 37.39],[128.12 37.18],[128.31 36.95],[128.55 36.81],[128.63 36.56],[128.57 36.36],[128.54 36.17],[128.56 35.91],[128.73 35.77],[128.78 35.59],[128.83 35.38],[128.97 35.23],[129.19 35.81],[129.13 35.56],[129.28 35.43],[126.94 37.33],[127.28 37.25],[127.78 37.27],[128.08 37.44],[128.35 37.56],[128.63 37.67],[128.83 37.77],[127.02 37.02],[127.33 36.98],[127.63 36.99],[126.81 36.65],[127.24 36.46],[127.7 36.28],[128.03 36.15],[128.4 36.03],[128.9 36.03],[129.29 36.05],[126.68 35.1],[127.23 35.21],[127.35 35.02],[127.86 35.03],[128.28 35.24],[127.58 35.49],[128.09 35.71]};
%-----------
es = 12630;%区域最左边点的经度
ed = 12920;%区域最右边点的经度
ns = 3456;%区域最下边点的纬度
nd = 3804;%区域最上面点的纬度

%-----------以下是炼丹参数QAQ
c1=2;c2=2;%学习参数
w=0.4;%惯性权值
vmaxX=0.1;vmaxY=0.1;%速度初始化
max=10;%迭代次数

%以下参数可以不用去动
xcs=cell(1,cs);%生成元胞数组
ycs=[];%极值列表
pbestcs=[];%个体最优解
vcsX=[];%随机速度
vcsY=[];
tempdistance=[];
drawcsX=[];
drawcsY=[];

%以下进行初始化
%初始点生成
for i=1:cs %生成农村super与随机速度
    while(1)
        tempX=0;tempY=0;
        tempX = randi([es,ed],1,1)/100;%生成随机经度
        tempY = randi([ns,nd],1,1)/100;%生成随机纬度
        in=inpolygon(tempX,tempY,xv,yv);%生成点是否在里面
        if (in == 1)%点在里面
            xcs{1,i} = [tempX tempY];
            break;
        end
    end
    vcsX(i)=rand()/10;
    vcsY(i)=rand()/10;
end

%调用适应度函数,计算出直线距离,经度距离，纬度距离,最近城市坐标
[ycs,nemiddle]=fitness(xcs,middle);
%初始化当前个体极值，并找到群体极值
for i=1:cs
   pbestcs(i)=ycs(i);
end
middlenearPoint={};
for i=1:length(middle)
    tempNumber=10^6;
    for j=1:cs
       if((middle{1,i}(1,1)==nemiddle{1,j}(1,1))&&(middle{1,i}(1,2)==nemiddle{1,j}(1,2)))
           if(pbestcs(j)<tempNumber)
               middlenearPoint{1,i}=xcs{1,j}; %找到距离该中点最近的点
               tempNumber=pbestcs(j);
           end
       end
    end
    if (tempNumber==10^6)%没有发现该点
        middlenearPoint{1,i}=0;%所有点离该农村都很远
    end
end

% 初始化完成
% 进行粒子群算法
for i=1:max
    for j=1:cs
        %更新位置与速度，采用分量的形式，同时更新经度与纬度
        gbestcs=middlenearPoint{1,nemiddle{1,j}(1,3)};
        vcsX(j)=w*vcsX(j)+c1*rand()*(nemiddle{1,j}(1,1)-xcs{1,j}(1,1))+c2*rand()*(gbestcs(1)-xcs{1,j}(1,1));
        vcsY(j)=w*vcsY(j)+c1*rand()*(nemiddle{1,j}(1,2)-xcs{1,j}(1,2))+c2*rand()*(gbestcs(2)-xcs{1,j}(1,2));
        if (vcsX(j)>vmaxX) 
            vcsX(j)=vmaxX;
        end
        if (vcsX(j)>vmaxX) 
            vcsX(j)=vmaxX;
        end
            xcs{1,j}=[xcs{1,j}(1,1)+vcsX(j) xcs{1,j}(1,2)+vcsY(j)];
        %越界判断
         in=inpolygon(xcs{1,j}(1,1),xcs{1,j}(1,2),xv,yv);%生成点是否在里面
         if (in == 0) %越界了
             point=1;value=0;
             for k=1:length(xv)
                 tempdistance(k)=distance(xcs{1,j},[xv(k) yv(k)]);
             end
             [value, point]=min(tempdistance);
             xcs{1,j}=[xv(point) yv(point)];           
         end    
    end
         [ycs,nemiddle]=fitness(xcs,middle);
         %更新个体与群体极值
         for l=1:cs
             if (ycs(l)>pbestcs(l))
                 pbestcs(l)=ycs(l);
             end
         end
         for m=1:length(middle)
            tempNumber=10^6;
            for n=1:cs
                if((middle{1,m}(1,1)==nemiddle{1,n}(1,1))&&(middle{1,m}(1,2)==nemiddle{1,n}(1,2)))
                    if(pbestcs(n)<tempNumber)
                        middlenearPoint{1,m}=xcs{1,n}; %找到距离该城市最近的点,顺便保存第几个点最近
                        tempNumber=pbestcs(n);
                    end
                end
            end
            if (tempNumber==10^6)%没有发现该点
                middlenearPoint{1,m}=0;%所有点离该城市都很远
            end
         end
end
         for k=1:cs
            drawcsX(k)=xcs{1,k}(1,1);
            drawcsY(k)=xcs{1,k}(1,2);
         end

plot(xv,yv,'r',cityshowX,cityshowY,'o',drawcsX,drawcsY,'*b');



